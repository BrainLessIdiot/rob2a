#pragma config(Sensor, in1,    PotentioSensor, sensorPotentiometer)
#pragma config(Sensor, in3,    lineFollowerRIGHT, sensorLineFollower)
#pragma config(Sensor, in4,    lineFollowerCENTER, sensorLineFollower)
#pragma config(Sensor, in5,    lineFollowerLEFT, sensorLineFollower)
#pragma config(Sensor, dgtl1,  gyro,           sensorNone)
#pragma config(Sensor, dgtl5,  inputSonar,     sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  Button,         sensorTouch)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex269, openLoop)
#pragma config(Motor,  port7,           udMotor,       tmotorVex269, openLoop)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex269, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This program allows a Robot to fallow a line by determening if the line is black or white by using sensor *\\
// underneath the robot if there is white it will either turn left or right depending on wich sensor is      	\\
// triggered like if the right sensor is triggered then it will go to the left and so on if you press the    	\\
// button in front of the robot then it will stop all tasks.
//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
const int POTENTIO = 1760;
const int BASETIME = 450;

void follow_line(){
	wait1Msec(200);          // The program waits for 2000 milliseconds before continuing.

  int threshold = 2500;
  int threshold2 = 2700;    /* found by taking a reading on both DARK and LIGHT    */
                        /* surfaces, adding them together, then dividing by 2. */
  while (SensorValue[inputSonar] < 30);
  {
		 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -+
    displayLCDCenteredString(0, "LEFT  CNTR  RGHT");        //  Display   |
    displayLCDPos(1,0);                                     //  Sensor    |
    displayNextLCDNumber(SensorValue(lineFollowerLEFT));    //  Readings  |
    displayLCDPos(1,6);                                     //  to LCD.   |
    displayNextLCDNumber(SensorValue(lineFollowerCENTER));  //            |
    displayLCDPos(1,12);                                    //  L  C  R   |
    displayNextLCDNumber(SensorValue(lineFollowerRIGHT));   //  x  x  x   |
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -+
    // RIGHT sensor sees dark:
    if(SensorValue(lineFollowerRIGHT) > threshold)
    {
      // counter-steer right:
      motor[leftMotor]  = 80;
      motor[rightMotor] = 0;
    }
    // CENTER sensor sees dark:
    if(SensorValue(lineFollowerCENTER) > threshold2)
    {
      // go straight
      motor[leftMotor]  = 80;
      motor[rightMotor] = 80;
    }
    // LEFT sensor sees dark:
    if(SensorValue(lineFollowerLEFT) > threshold)
    {
      // counter-steer left:
      motor[leftMotor]  = 0;
      motor[rightMotor] = 80;
    }
 }


}

void arm_down()
{
		motor[udMotor] = 30;
}

void arm_up()
{
		motor[udMotor] = -30;
}

void claw_close()
{
		motor[clawMotor] = 40;
}

void turn_around(int i)
{
	motor[leftMotor] = -40;
	motor[rightMotor] = 40;
	wait1Msec(BASETIME*i)
}



task main()
{
	while(SensorValue[Button] < 1)
		follow_line();
	if (SensorValue[inputSonar] < 30);
		arm_down();
		claw_close();
		arm_up();
		turn_around(i);



}
